---
title: 多线程(面试题)汇总
tags: 多线程
abbrlink: 40898
date: 2018-03-16 12:25:08
modified: 2020-10-28 22:53:59
---

# 多线程(面试题)汇总

### 目录

- 实际问题
  - 子线程同时执行ABC三个同步任务、全部执行完成再在子线程执行三个同步任务EDF。
  - 上一题中的ABC三个任务改成异步任务(如AFN网络请求)、全部回调成功后进行数据整合。
  - 实现本地大体量数组内容的实时输入搜索(如通讯录搜索好友名称/ID)。
- 问题汇总
  - 并行和并发的区别？
  - 串行/并行、同步异步的区别?(附带如何判断GCD的执行顺序、是否开辟线程)
  - `NSOperation`与`GCD`的关系
  - 默认最大并发
  - 线程取消
  - `[thread cancel]`可以关闭线程？
  - `performSelector`开头那么多方法为什么分散在不同的文件里？
  - `NSBlockOperation`和`NSInvocationOperation`有什么关系和区别。
  - `NSInvocationOperation`如何解决参数受限的问题
  - `NSOperation`可以像`GCD`一样设置串行并行么？
  - `NSOperation`队列内操作执行的时间点
  - `NSOperation`设置优先级是否可以直接决定操作的执行顺序?
  - `NSBlockOperation` 用 `addExecutionBlock` 追加的操作、是否为串行执行。如果不是、为什么要这么设计？
  - 主队列(`[NSOperationQueue mainQueue]`)可以不可以修改最大并发数？主队列下添加的操作、都会在主线程执行么？
  - GCD的并行队列一定会开辟新的线程？
  - `dispatch_once`如何实现一次性代码？
  - `NSOperation`的添加进队列后可不可以追加依赖?`GCD任务组`添加监听后可不可以追加任务?
- 不同线程对比

<!-- more -->

------

### 实际问题

这个不太可能让人真的手写代码或者上机、根据回答的点大概可以揣测一些水平吧？

- ###### 子线程同时执行ABC三个同步任务、全部执行完成再在子线程执行三个同步任务EDF。

说队列组/依赖基本可以确定了解GCD/NSOpertion。但是比较麻烦、用线程栅栏`dispatch_barrier`的话会更简便一些。

- ##### 上一题中的ABC三个任务改成异步任务(如AFN网络请求)、全部回调成功后进行数据整合。

如果只说队列/任务组肯定不行。因为网络请求本身是异步的、任务会立即完成、但数据还没有回来。这样就有两种方式
 1、把异步的网络请求转化为同步、以捕获正确的完成时机。
 **具体操作需要使用`信号量`。**
 2、是使用`dispatch_group_enter`以及`dispatch_group_leave`的搭配。
 这个要感谢评论区[《9b298c9c5162》](https://www.jianshu.com/u/9b298c9c5162)的提示。

- ##### 实现本地大体量数组内容的实时输入搜索(如通讯录搜索好友名称/ID)

1、每次输入字符的时候。如何进行数据遍历(如果用的For、那么为什么不用GCD的快速迭代？----因为开辟线程以及线程同步需要些许耗时、对于非耗时操作、for的性能会更好一些)。
 2、每次输入字符的时候。如何废弃之前的搜索任务、以免重复插入(NSOperationQueue之类)。
 3、高频次使用searchArray数组时的安全性。(锁)

### 问题汇总

- ##### 并行和并发的区别？

  - 并发是指两个或多个事件在同一时间间隔内发生。
     例如单CPU的处理多线程。
  - 并行是指两个或者多个事件在同一时刻发生
     例如多CPU的处理多线程。

- ##### 串行/并行、同步异步的区别?(附带如何判断GCD的执行顺序、是否开辟线程)

  - (同步/异步)任务
     决定代码块是否会阻塞当前线程、并且插入指定队列的末尾执行。
  - (串行/并行/主)队列

1. 异步任务下、(串行/并行/主)队列决定将由哪条队列的线程执行代码块。
    串行队列/主队列维护一条线程、并行队列维护多条线程。
2. 同步任务下、(串行/并行)队列使得代码块一定是在当前线程执行(主队列则交给主队列执行)、但要考虑死锁。

- 死锁的条件
   **1. 在一个串行队列维护的线程内、让该串行队列执行同步任务。**
   最经典的就是、在主线程内让主线程执行同步任务。
   **既阻塞了当前线程、又想在当前线程末尾执行。**

![Xnip2020-10-27_22-37-22](https://gitee.com/coderiding/picbed/raw/master/uPic/Xnip2020-10-27_22-37-22.jpg)

这里不管你中间怎么使用、只通过线程和队列就能判断。

1. 比较奇葩一个循环内、连续的同步任务串行下出现两次相同的串行队列。
    感觉没人会这么写、除非是神经病。

![Xnip2020-10-27_22-37-53](https://gitee.com/coderiding/picbed/raw/master/uPic/Xnip2020-10-27_22-37-53.jpg)



但如果其中修改一个为并行队列、或者异步任务。就没有问题。

判断最终结果时：**先看任务类型、然后看队列情况。**

- ##### `NSOperation`与`GCD`的关系

GCD基于C、NSOperation基于GCD的封装。

- ##### 默认最大并发

  - NSThread
     本身并**不会限制**、也不支持限制最大并发(起码支持是四位数以内、如果超过某个阈值会error`[NSThread start]: Thread creation failed with error 35`)

```objectivec
- (void)thread_bingfa {
    for (int a = 0; a < 1000; a ++) {
        [self performSelectorInBackground:@selector(aaa:) withObject:[NSNumber numberWithInt:a]];
    }
}

- (void)aaa:(NSNumber *)number {
    for (int a = 0; a < 100; a++) {
        sleep(1);
        NSLog(@"%@",number);
    }
}
```

![Xnip2020-10-27_22-56-16](https://gitee.com/coderiding/picbed/raw/master/uPic/Xnip2020-10-27_22-56-16.jpg)

最大并发_NSThread

- NSOperation
   默认的限制大概三位数以下(我模拟器分配到了63)



```objectivec
    self.operationQueue=[[NSOperationQueue alloc]init];

- (void)viewDidLoad {
    for (int a = 0; a < 10000; a ++) {
        [self bbb:a];
    }
}

- (void)bbb:(int)a {

        [self.operationQueue addOperationWithBlock:^{
            for (int i = 0; i < 100; i ++) {
                sleep(10);
                NSLog(@"%d",a);
            }
        }];
}
```

![Xnip2020-10-27_22-57-04](https://gitee.com/coderiding/picbed/raw/master/uPic/Xnip2020-10-27_22-57-04.jpg)

最大并发_NSOperation

- GCD
   默认的最大并发和NSOperation相同。
   **毕竟NSOperation基于GCD的OC封装**、倒也说得通。

- ##### `[thread cancel]`可以关闭线程？

不能、只能把对应线程进行cancel标记。详见[下文]((https://www.jianshu.com/p/3bb2afebbc27))`NSThread相关的几个坑`。

- ##### `performSelector`开头那么多方法为什么分散在不同的文件里?

分散在`NSThread.h`、`NSRunLoop.h`、`NSObject.h`。
 详见[下文](https://www.jianshu.com/p/3bb2afebbc27)`一些NSObject的相关扩展方法（performSelector）`.

- ##### `NSBlockOperation`和`NSInvocationOperation`有什么关系和区别。

  - 二者都是NSOperation的子类、都可以被添加进队列中(或者自己主动)执行。
  - NSBlockOperation可以解决NSInvocationOperation传递参数受限的问题。

- ##### `NSInvocationOperation`如何解决参数受限的问题

这个问题其实和解决`- (id)performSelector:(SEL)aSelector withObject:(id)object`下方法受限的方式一样。
 1、使用字典。
 2、NSInvocationOperation实际上就是方法签名`NSInvocation`。所以如果使用`NSInvocation`进行初始化也能解决参数受限的问题、只是太麻烦了、除非特定情况(目前我接触到的只有模块化的Route层)不然不推荐。

- ##### `NSOperation`可以像GCD一样设置串行并行么？

串行并行实际上是GCD的名词。
 **并行意味着多线程执行任务、串行意味着单线程执行任务。**
 **任务在每一个线程内部、其实都是串行的。**
 NSOperation并没有串行并行的概念、自然也谈不上设置。
 **但是**我们可以通过通过设置某个队列(NSOperationQueue)的最大并发数为1、让其中任务们(NSOperation)自动被分配到不同线程中自动执行、以达到**串行/并行**的底层结果。

- ##### `NSOperation`队列内操作执行的时间点:

  - 所有操作在被添加到队列中时、立即进行如下判断:
    - 如果所插入的操作存在依赖关系、优先完成依赖操作。
    - **如果所插入的操作不存在依赖关系、队列并发数为1下采用先进先出的原则、反之直接开辟新的线程执行。**
       （具体可见[下文](https://www.jianshu.com/p/8f42431fa466)NSOperation --> **操作的执行顺序**）
  - 当一个操作执行完成之后、队列会取出对其有依赖的所有操作、进行下一步判断：
    - 如果该操作没有其他依赖(准备就绪、`isReady`属性)、进行下一步判断
    - 所有可以执行的操作根据优先级排序执行。
       （具体可见[下文](https://www.jianshu.com/p/8f42431fa466)NSOperation -->  **操作的优先级**）

- ##### `NSOperation`设置优先级是否可以直接决定操作的执行顺序?

**不能**、优先级的判定是建立在依赖操作完成后对下一步操作的排序下。
 具体可见[下文](https://www.jianshu.com/p/8f42431fa466)NSOperation -->  **操作的优先级**

- ##### `NSBlockOperation` 用 `addExecutionBlock` 追加的操作、是否为串行执行。如果不是、为什么要这么设计？

**不是**、默认的操作会被置于队列开辟的首个线程(主队列则为主线程)、剩余的操作会开辟新的线程并发执行。但是有并发数限制、由系统分配。
 至于为什么这么设计。
 **NSBlockOperation**下所有的操作默认情况下也是并行的。由并行通过依赖控制成串行容易、但由由串行想做出并行的效果则很难。
 **比如需要同时下载三张图片下载完成之后、将其展示。**
 我可以将三个下载操作追加进一个blockOperation1、再让展示操作的BlockOperation2依赖BlockOperation1。

```objectivec
    NSOperationQueue *operationQueue=[NSOperationQueue mainQueue];
    
    NSBlockOperation *blockOperation1=[NSBlockOperation blockOperationWithBlock:^{
        sleep(1);
        NSLog(@"下载任务--%d",1);
    }];

    for (int i=2; i<4; ++i) {
        [blockOperation1 addExecutionBlock:^{
            sleep(1);
            NSLog(@"下载任务--%d",i);
        }];
    }
    
    NSBlockOperation *blockOperation2=[NSBlockOperation blockOperationWithBlock:^{
        sleep(1);
        NSLog(@"展示任务");
    }];
    [blockOperation2 addDependency:blockOperation1];
    
    
    [operationQueue addOperation:blockOperation1];
    [operationQueue addOperation:blockOperation2];
```

打印结果

```css
2018-03-16 16:34:02.388806+0800 test[5620:522718] 下载任务--2
2018-03-16 16:34:02.388806+0800 test[5620:522602] 下载任务--1
2018-03-16 16:34:02.388806+0800 test[5620:522717] 下载任务--3
2018-03-16 16:34:03.390790+0800 test[5620:522602] 展示任务
```

如果`addExecutionBlock`的操作是串行的。那么我只能创建三个下载操作、然后将展示操作依赖于以上三个操作。得不偿失。

- ##### 主队列(`[NSOperationQueue mainQueue]`)可以不可以修改最大并发数？主队列下添加的操作、都会在主线程执行么？

  - 不能、主队列的最大并发数始终为1(自定义队列默认为-1)、且修改无效。
  - 默认状况下是的、但也有例外（追加操作`addExecutionBlock`）。

- ##### GCD的并行队列一定会开辟新的线程？

**不**

![Xnip2020-10-28_22-18-40](https://gitee.com/coderiding/picbed/raw/master/uPic/Xnip2020-10-28_22-18-40.jpg)

GCD



- ##### `dispatch_once`如何实现一次性代码？

详情可以[查阅](https://www.jianshu.com/p/96b93aa05bcd)GCD-->一次性代码(单例)

- ##### `NSOperation`的添加进队列后可不可以追加依赖?`GCD任务组`添加监听后可不可以追加任务?

  - NSOperation的依赖必须在添加进队列(并且执行前)之前设置。(**但是我们可以对某被依赖的操作进行追加`addExecutionBlock`以延缓调用**)
  - GCD任务组则具备追加任务的功能。前提是监听并未被触发。

具体可以详见相应[下文](https://www.jianshu.com/p/8f42431fa466)`NSOperation --> 队列插入操作后的执行顺序`、[下文](https://www.jianshu.com/p/96b93aa05bcd)`GCD -- > 队列组`

------

### 不同线程对比

主要说GCD和NSOperation、如果NSThread方便实现的话可能会提一句。

##### 线程切换

- NSThread

```objectivec
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
  
    
    [self performSelectorInBackground:@selector(fun1) withObject:nil];
}

- (void)fun1 {
    //回到主线程
    [self performSelectorOnMainThread:@selector(fun2) withObject:nil waitUntilDone:nil];
}
```

- GCD
   创建/获取一个并行队列添加任务、然后返回主队列

```cpp
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
dispatch_async(queue, ^{
    // 执行耗时的异步操作...
    dispatch_async(dispatch_get_main_queue(), ^{
      // 回到主线程，执行UI刷新操作
    });
});
```

- NSOperation
   创建队列添加操作、然后返回主队列



```objectivec
NSOperationQueue * queue = [[NSOperationQueue alloc]init];

//切换到子线程
[queue addOperationWithBlock:^{
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
        //切换回主线程
    }];
}];
```

- ##### 队列组/依赖

- GCD

```objectivec
- (void)dispatch_group_test {
    
    dispatch_queue_t queue = dispatch_queue_create("queue_test", DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue, ^{
        NSLog(@"任务1——准备休眠3秒");
        sleep(3);
        NSLog(@"任务1——完成");
    });
    
    NSLog(@"主线程——准备休眠5秒");
    sleep(5);
    NSLog(@"主线休眠结束");
    
    dispatch_group_async(group, queue, ^{
        NSLog(@"任务2——准备休眠10秒");
        sleep(10);
        NSLog(@"任务2——完成");
    });
    
    dispatch_group_notify(group, queue, ^{
        NSLog(@"任务组完成");
    });

    NSLog(@"主线程结束");
}
```

- NSOperation

```objectivec
//创建操作队列
NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];
//创建最后一个操作
NSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^{
    sleep(1);
    NSLog(@"最后的任务");
}];
for (int i=0; i<5-1; ++i) {
    //创建多线程操作
    NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
        sleep(i);
        NSLog(@"第%d个任务",i);
    }];
    //设置依赖操作为最后一个操作
    [blockOperation addDependency:lastBlockOperation];
    [operationQueue addOperation:blockOperation];
    
}
//将最后一个操作加入线程队列
[operationQueue addOperation:lastBlockOperation];
```

- GCD
  - 适用于多个任务同时执行、可以捕获所有任务完成的回调。
  - 任务添加到队列组、且未全部完成时可以向任务组中添加任务。
- NSOperation
  - 适用于多个任务之间相互依赖等待、最后完成的时候并没有回调。
  - 添加到队列中(并且已经执行)的操作不能再新增依赖、但是可以向追加操作。

##### 串行队列

- GCD
   两种方式获取/创建

```cpp
//主队列--串行
dispatch_queue_t queue1 = dispatch_get_main_queue();
//自定义串行队列
dispatch_queue_t queue2 = dispatch_queue_create("test_queue", DISPATCH_QUEUE_SERIAL);
```

- NSOperation
   两种方式获取/创建

```objectivec
//主队列
NSOperationQueue * queue1 = [NSOperationQueue mainQueue];
//自定义队列 -- 把并发改为1
NSOperationQueue * queue2 = [[NSOperationQueue alloc]init];
queue2.maxConcurrentOperationCount = 1;
```

##### 最大并发

- GCD
   通过信号量进行约束。[详见](https://www.jianshu.com/p/96b93aa05bcd)GCD-->信号量

```cpp
// 创建队列组
dispatch_group_t group = dispatch_group_create();
// 创建信号量，并且设置值为3
dispatch_semaphore_t semaphore = dispatch_semaphore_create(3);
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
for (int i = 0; i < 100; i++)
{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    dispatch_group_async(group, queue, ^{
        NSLog(@"%i",i);
        sleep(2);
        // 每次发送信号则semaphore会+1，
        dispatch_semaphore_signal(semaphore);
    });
}
```

- NSOperation
   直接设置

```objectivec
NSOperationQueue * queue2 = [[NSOperationQueue alloc]init];
queue2.maxConcurrentOperationCount = 3;
```



# gcd

### 目录

- GCD
  - 队列`dispatch_queue_t`
  - 线程的开辟与阻塞机制
  - 一次性代码(单例)
  - 队列组
  - GCD定时器
  - 快速遍历`dispatch_apply`
  - 信号量
  - 线程栅栏
  - GCD的API

#### GCD

##### 队列`dispatch_queue_t`

GCD中有两种队列、并且每种队列都有两种创建方式(系统默认+自定义)

- ##### 串行队列

1、主队列:

```undefined
dispatch_get_main_queue()
```

2、自定义队列(串行):(参数为优先级、第二个参数`DISPATCH_QUEUE_SERIAL`实际上是指向'NULL'的宏)

```bash
dispatch_queue_create("queue_name", DISPATCH_QUEUE_SERIAL)
```

- ##### 并行队列

1、全局队列:(参数为优先级、第二个参数为0)

```undefined
dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
```

2、自定义队列(并行):

```bash
dispatch_queue_create("ss_queue", DISPATCH_QUEUE_CONCURRENT)
```

可以看出来、自定义队列都是使用`dispatch_queue_create('队列名','队列类型')`进行创建。

#### 线程的开辟与阻塞机制

- 并行和串行主要影响：任务的执行方式

> 并行：多个任务并发（同时）执行
>  串行：一个任务执行完毕后，再执行下一个任务

- 同步和异步主要影响：能不能开启新的线程

> 同步：在当前线程中执行任务，不具备开启新线程的能力
>  异步：在新的线程中执行任务，具备开启新线程的能力

- **会开辟新线程的两种情况**
  - 并行队列+异步任务 = 多条新线程
  - 自定义串行多列+异步任务 = 一条新线程
- 其余情况、全部将会置于当前线程/主线程(主队列任务)下执行。

![Xnip2020-10-28_22-33-04](https://gitee.com/coderiding/picbed/raw/master/uPic/Xnip2020-10-28_22-33-04.jpg)

GCD

用我们常用的代码举个例子：

```objectivec
dispatch_queue_t q = dispatch_queue_create("test.q", DISPATCH_QUEUE_CONCURRENT);

dispatch_async(q, ^{
    for (int i = 0; i < 100000; i ++) {
        NSLog(@"2--%d----%@",i,[NSThread currentThread]);
        sleep(3);
    }
});

dispatch_async(q, ^{
    for (int i = 0; i < 100000; i ++) {
       NSLog(@"1---%d----%@",i,[NSThread currentThread]);
       sleep(3);
    }
});
```

打印结果:

```tsx
2018-03-19 15:32:12.591483+0800 test[5002:479872] 1---0----<NSThread: 0x600000278140>{number = 4, name = (null)}
2018-03-19 15:32:12.591549+0800 test[5002:479875] 2--0----<NSThread: 0x60400027b240>{number = 3, name = (null)}
2018-03-19 15:32:15.595894+0800 test[5002:479872] 1---1----<NSThread: 0x600000278140>{number = 4, name = (null)}
2018-03-19 15:32:15.595894+0800 test[5002:479875] 2--1----<NSThread: 0x60400027b240>{number = 3, name = (null)}
2018-03-19 15:32:18.601144+0800 test[5002:479872] 1---2----<NSThread: 0x600000278140>{number = 4, name = (null)}
2018-03-19 15:32:18.601144+0800 test[5002:479875] 2--2----<NSThread: 0x60400027b240>{number = 3, name = (null)}
```

这就是上面所说的`并行队列+异步任务 = 多条新线程`。

如果我们把`DISPATCH_QUEUE_CONCURRENT`换成`DISPATCH_QUEUE_SERIAL`
 打印结果又会变成

```tsx
2018-03-19 15:40:20.491705+0800 test[5083:493760] 2--0----<NSThread: 0x600000278d00>{number = 3, name = (null)}
2018-03-19 15:40:23.493296+0800 test[5083:493760] 2--1----<NSThread: 0x600000278d00>{number = 3, name = (null)}
2018-03-19 15:40:26.497652+0800 test[5083:493760] 2--2----<NSThread: 0x600000278d00>{number = 3, name = (null)}
```

所有的输出都集中在number = 3的新线程中。

#### 一次性代码(单例)

```objectivec
static id obj = nil;
+ (NSObject *)getObj
{
    static NSObject* obj;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        obj = [[NSObject alloc]init];
    });
    return obj;
}
```

- `dispatch_once`的实现原理

```objectivec
- (NSObject *)getObj
{
    static NSObject* obj;
    static dispatch_once_t onceToken;
    NSLog(@"1::::%ld",onceToken);
    dispatch_once(&onceToken, ^{
        NSLog(@"2::::%ld",onceToken);
        obj = [[NSObject alloc]init];
        NSLog(@"3::::%ld",onceToken);
    });
    NSLog(@"4::::%ld",onceToken);
    return obj;
}
```

打印结果:

```css
2018-03-20 18:08:04.066961+0800 test[5861:729479] 1::::0
2018-03-20 18:08:04.067124+0800 test[5861:729479] 2::::768
2018-03-20 18:08:04.067256+0800 test[5861:729479] 3::::768
2018-03-20 18:08:04.067355+0800 test[5861:729479] 4::::-1
```

所以

- 当onceToken == 0 的时候、才允许进入函数内部执行初始化的block。
- block执行完将onceToken修改。
- (稍微扩展一下啊)当多个线程同时调用`dispatch_once`方法的时候、内部会借用信号量来进行线程控制、进一步保证每个block代码只执行一次。

更多的查看[GCD外传：dispatch_once(上)](http://www.dreamingwish.com/article/gcd-guide-dispatch-once-1.html)、[细说@synchronized和dispatch_once](https://www.jianshu.com/p/ef3f77c8b320)

#### 队列组`dispatch_group`

```objectivec
//队列组
- (void)dispatch_group_test {
    
    dispatch_queue_t queue = dispatch_queue_create("queue_test", DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue, ^{
        NSLog(@"任务1——准备休眠3秒");
        sleep(3);
        NSLog(@"任务1——完成");
    });
    
    NSLog(@"主线程——准备休眠5秒");
    sleep(5);
    NSLog(@"主线休眠结束");
    
    dispatch_group_async(group, queue, ^{
        NSLog(@"任务2——准备休眠10秒");
        sleep(10);
        NSLog(@"任务2——完成");
    });
    
    dispatch_group_notify(group, queue, ^{
        NSLog(@"任务组完成");
    });

    NSLog(@"主线程结束");
}
```

打印结果:

```css
2018-03-20 10:43:32.135642+0800 test[1763:94602] 主线程——准备休眠5秒
2018-03-20 10:43:32.135649+0800 test[1763:94645] 任务1——准备休眠3秒
2018-03-20 10:43:35.141269+0800 test[1763:94645] 任务1——完成
2018-03-20 10:43:37.137225+0800 test[1763:94602] 主线休眠结束
2018-03-20 10:43:37.137513+0800 test[1763:94602] 主线程结束
2018-03-20 10:43:37.137515+0800 test[1763:94645] 任务2——准备休眠10秒
2018-03-20 10:43:47.139737+0800 test[1763:94645] 任务2——完成
2018-03-20 10:43:47.140116+0800 test[1763:94645] 任务组完成
```

**这里可以扩展一下任务组的机制**

- `dispatch_group_notify`任务组的结束通知可以添加多次、并且会多次调用。

- 类似于NSOperation中的依赖、GCD的group监听是可以追加的。只要任务组中的任务没有全部完成, ，group完成的监听就不会被调用，哪怕是后追加的任务。

  ![Xnip2020-10-28_22-37-08](https://gitee.com/coderiding/picbed/raw/master/uPic/Xnip2020-10-28_22-37-08.jpg)


```objectivec
//队列组
- (void)dispatch_group_test {
    
    dispatch_queue_t queue = dispatch_queue_create("queue_test", DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue, ^{
        NSLog(@"任务1——准备休眠3秒");
        sleep(3);
        NSLog(@"任务1——完成");
    });
    
    NSLog(@"添加完成监听");
    dispatch_group_notify(group, queue, ^{
        NSLog(@"任务组完成");
    });

    dispatch_group_async(group, queue, ^{
        NSLog(@"任务2——准备休眠10秒");
        sleep(10);
        NSLog(@"任务2——完成");
    });

    NSLog(@"主线程结束");
}
```

打印结果

```css
2018-03-20 10:49:16.192283+0800 test[1866:104770] 添加完成监听
2018-03-20 10:49:16.192284+0800 test[1866:104819] 任务1——准备休眠3秒
2018-03-20 10:49:16.192519+0800 test[1866:104770] 主线程结束
2018-03-20 10:49:16.192534+0800 test[1866:104930] 任务2——准备休眠10秒
2018-03-20 10:49:19.197851+0800 test[1866:104819] 任务1——完成
2018-03-20 10:49:26.198201+0800 test[1866:104930] 任务2——完成
2018-03-20 10:49:26.198583+0800 test[1866:104930] 任务组完成
```

- 任务组是可以跨队列监听的
   所以、监听中的第二个参数(队列)到底是干嘛的~希望有大神指正

> ***评论区已经有大神回复：\***
>  第二个参数决定了监听函数的callback将会在哪个队列执行。
>  比如你希望在异步任务完成之后、回到主线程刷新页面。

```objectivec
- (void)dispatch_group_test {
    
    dispatch_queue_t queue = dispatch_queue_create("queue_test", DISPATCH_QUEUE_CONCURRENT);
    dispatch_queue_t queue2 = dispatch_queue_create("queue_test", DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue2, ^{
        NSLog(@"任务1——准备休眠3秒");
        sleep(3);
        NSLog(@"任务1——完成");
    });
    
    NSLog(@"添加完成监听");
    dispatch_group_notify(group, queue, ^{
        NSLog(@"任务组完成");
    });

    NSLog(@"主线程结束");
}
```

打印结果:

```css
2018-03-20 13:06:11.267924+0800 test[2243:234892] 添加完成监听
2018-03-20 13:06:11.267935+0800 test[2243:235001] 任务1——准备休眠3秒
2018-03-20 13:06:11.268402+0800 test[2243:234892] 主线程结束
2018-03-20 13:06:14.269280+0800 test[2243:235001] 任务1——完成
2018-03-20 13:06:14.269575+0800 test[2243:235001] 任务组完成
```

#### 快速遍历`dispatch_apply`

GCD提供了多线程快速遍历的方法。需要注意的是:

- 由于多线程遍历、输出的下标未必按照顺序排列。
- 本质上是一个同步任务、而内部会使用一个并行队列用异步任务进行遍历。(所以如果需要、需要在外部自己开辟一个新的异步任务)

```objectivec
- (void)dispatch_apply_test {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_async(queue, ^{
        dispatch_apply(10, queue, ^(size_t index) {
            NSLog(@"%@-%ld",[NSThread currentThread],index);
            sleep(10);
        });
        NSLog(@"任务完成");
    });
    NSLog(@"主线程结束");
}
```

打印结果:

```tsx
2018-03-20 13:27:38.463507+0800 test[2491:271571] 主线程结束
2018-03-20 13:27:38.463630+0800 test[2491:271633] <NSThread: 0x60400026e180>{number = 3, name = (null)}-0
2018-03-20 13:27:38.463639+0800 test[2491:271928] <NSThread: 0x604000274680>{number = 4, name = (null)}-1
2018-03-20 13:27:38.463713+0800 test[2491:271932] <NSThread: 0x60000007ccc0>{number = 5, name = (null)}-2
2018-03-20 13:27:38.463715+0800 test[2491:271933] <NSThread: 0x60400026ecc0>{number = 6, name = (null)}-3
2018-03-20 13:27:48.468368+0800 test[2491:271932] <NSThread: 0x60000007ccc0>{number = 5, name = (null)}-6
2018-03-20 13:27:48.468368+0800 test[2491:271928] <NSThread: 0x604000274680>{number = 4, name = (null)}-4
2018-03-20 13:27:48.468382+0800 test[2491:271933] <NSThread: 0x60400026ecc0>{number = 6, name = (null)}-7
2018-03-20 13:27:48.468392+0800 test[2491:271633] <NSThread: 0x60400026e180>{number = 3, name = (null)}-5
2018-03-20 13:27:58.471068+0800 test[2491:271932] <NSThread: 0x60000007ccc0>{number = 5, name = (null)}-9
2018-03-20 13:27:58.471068+0800 test[2491:271933] <NSThread: 0x60400026ecc0>{number = 6, name = (null)}-8
2018-03-20 13:28:08.473167+0800 test[2491:271633] 任务完成
```

#### GCD定时器

不同于基于Runloop的`NSTimer`。`dispatch_source_t`不会因为子线程没有正在运行的Runloop而失效、循环引用、计时不准(每次runloop循环才会检查定时器是否需要被执行)等问题。
 也有几个点需要注意:

- `source`最好被持有、不然在暂停`dispatch_suspend`的时候可能会Crash。
- 暂停`dispatch_suspend`/开始`resumeTimer`一定要成对使用、否则会Crash。
- 可`dispatch_source_t`并没有检查`source`本身状态的API。

```objectivec
@interface ViewController ()

@property (nonatomic, strong) dispatch_source_t timer;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    // 创建定时器,(dispatch_source_t本质是OC对象)
    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());

    // 设置定时器的实践参数，时间参数一般是纳秒（1秒 == 10的9次方纳秒）为单位
    // 何时开始
    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (ino64_t)(1.0 * NSEC_PER_SEC));
    // 时间间隔
    uint64_t interval = (uint64_t)(2.0 * NSEC_PER_SEC);
    // 设置参数
    dispatch_source_set_timer(self.timer, start, interval, 0);

    // 设置回调，即设置需要定时器定时执行的操作
    dispatch_source_set_event_handler(self.timer, ^{

        NSLog(@"------");

    });

    // 启动定时器
    dispatch_resume(self.timer);

}

//暂停
-(void) pauseTimer{  
    if(_timer){  
        dispatch_suspend(_timer);  
    }  
}  
//恢复
-(void) resumeTimer{  
    if(_timer){  
        dispatch_resume(_timer);  
    }  
}  
//销毁
-(void) stopTimer{  
    if(_timer){  
        dispatch_source_cancel(_timer);  
        _timer = nil;  
    }  
}  

@end
```

#### 信号量

信号量类似于锁。
 **简单来讲 信号量为0则阻塞线程，大于0则不会阻塞。则我们通过改变信号量的值，来控制是否阻塞线程，从而达到线程同步**
 GCD中的信号量含有三个函数:

- `dispatch_semaphore_create` 创建一个semaphore信号量

- `dispatch_semaphore_signal` 发送一个信号让信号量+1

- ```
  dispatch_semaphore_wait
  ```

   如果信号量计数为0则阻塞等待、否则通过。

  ![Xnip2020-10-28_22-39-06](https://gitee.com/coderiding/picbed/raw/master/uPic/Xnip2020-10-28_22-39-06.jpg)

具体的使用举两个例子吧。

- GCD控制并发数
   通过设置信号量初始值、达到GCD的并发。

```cpp
// 创建队列组
    dispatch_group_t group = dispatch_group_create();   
// 创建信号量，并且设置值为10
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);   
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);   
    for (int i = 0; i < 100; i++)   
    {   // 由于是异步执行的，所以每次循环Block里面的dispatch_semaphore_signal根本还没有执行就会执行dispatch_semaphore_wait，从而semaphore-1.当循环10此后，semaphore等于0，则会阻塞线程，直到执行了Block的dispatch_semaphore_signal 才会继续执行
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);   
        dispatch_group_async(group, queue, ^{   
            NSLog(@"%i",i);   
            sleep(2);   
// 每次发送信号则semaphore会+1，
            dispatch_semaphore_signal(semaphore);   
        });   
    }
```

- 异步任务转同步
   通过再方法末尾用信号量阻塞、直到异步请求完成后再通过。
   配合GCD任务组、NSOperation的依赖。可以达到多网络请求后的同步操作。

```objectivec
- (void)request1{
    //创建信号量并设置计数默认为0
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    manager.responseSerializer = [AFJSONResponseSerializer serializer];
    NSString *url = [NSString stringWithFormat:@"%s","http://v3.wufazhuce.com:8000/api/channel/movie/more/0?platform=ios&version=v4.0.1"];
    [manager GET:url parameters:nil progress:^(NSProgress * _Nonnull uploadProgress) {
        
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSArray *data = responseObject[@"data"];
        for (NSDictionary *dic in data) {
            NSLog(@"请求1---%@",dic[@"id"]);
        }
        //计数加1
        dispatch_semaphore_signal(semaphore);
        //11380-- data.lastObject[@"id"];
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@"shibai...");
        //计数加1
        dispatch_semaphore_signal(semaphore);
    }];
    //若计数为0则一直等待
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
}
```

#### 线程栅栏`dispatch_barrier`

线程栅栏可以阻塞某个`queue`中任务的执行直到`queue`中`栅栏`之前的任务被执行完毕。

```objectivec
- (void)dispatch_barrier_test {
    dispatch_queue_t queue = dispatch_queue_create("test_queue", DISPATCH_QUEUE_CONCURRENT);
    
    for (int i = 1; i <= 3; i ++) {
        dispatch_async(queue, ^{
            sleep(3);
            NSLog(@"任务%d结束",i);
        });
    }
    NSLog(@"代码经过栅栏");
    dispatch_barrier_sync(queue, ^{
        sleep(5);
        NSLog(@"栅栏结束");
    });
    NSLog(@"代码通过栅栏");
    
    for (int i = 4; i <= 6; i ++) {
        dispatch_async(queue, ^{
            sleep(3);
            NSLog(@"任务%d结束",i);
        });
    }
    NSLog(@"代码结束");
}
```

打印结果:

```css
2018-03-20 16:44:07.347195+0800 test[4987:607391] 代码经过栅栏
2018-03-20 16:44:10.351954+0800 test[4987:607438] 任务1结束
2018-03-20 16:44:10.351954+0800 test[4987:607439] 任务3结束
2018-03-20 16:44:10.351984+0800 test[4987:607440] 任务2结束
2018-03-20 16:44:15.353557+0800 test[4987:607391] 栅栏结束
2018-03-20 16:44:15.353836+0800 test[4987:607391] 代码通过栅栏
2018-03-20 16:44:15.354086+0800 test[4987:607391] 代码结束
2018-03-20 16:44:18.357376+0800 test[4987:607441] 任务5结束
2018-03-20 16:44:18.357369+0800 test[4987:607440] 任务4结束
2018-03-20 16:44:18.357457+0800 test[4987:607438] 任务6结束
```

将**同步栅栏**`dispatch_barrier_sync`换成**异步栅栏**`dispatch_barrier_async`

```css
2018-03-20 16:45:52.798543+0800 test[5025:610657] 代码经过栅栏
2018-03-20 16:45:52.798700+0800 test[5025:610657] 代码通过栅栏
2018-03-20 16:45:52.798823+0800 test[5025:610657] 代码结束
2018-03-20 16:45:55.798703+0800 test[5025:610699] 任务1结束
2018-03-20 16:45:55.798722+0800 test[5025:610702] 任务3结束
2018-03-20 16:45:55.798725+0800 test[5025:610698] 任务2结束
2018-03-20 16:46:00.800958+0800 test[5025:610698] 栅栏结束
2018-03-20 16:46:03.805894+0800 test[5025:610701] 任务6结束
2018-03-20 16:46:03.805886+0800 test[5025:610698] 任务4结束
2018-03-20 16:46:03.805987+0800 test[5025:610702] 任务5结束
```

很明显的区别在于

- 同步栅栏会阻塞之后普通代码的执行、异步栅栏则不会。
   应用线程栅栏的特性、我们可以更好的做一些线程同步。某些情况下不需要写好几层任务组来同步任务。

```undefined
例如4/5/6任务想要等待1/2/3任务。
用任务组的的话、需要一个任务组包含(1/2/3)。
然后在任务组完成的回调中再并发出三个任务(4/5/6)。
而且还无法控制线程的阻塞、除非在想要阻塞的地方加入最后一个同步任务。
想想就很麻烦....
```

#### GCD的API

这部分不是我自己写的、在查阅一些API资料的途中翻到了这篇博客。
 [《iOS多线程之GCD》](http://blog.csdn.net/qq_26790617/article/details/53340105)深表感谢。

```cpp
/* 

功能：将块函数添加到线程队列中异步执行（异步：执行后不管结果直接返回）

参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）

返回值：空

*/

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);

void dispatch_async_f(dispatch_queue_t queue,

void *_Nullable context,

dispatch_function_t work);

/* 

功能：将块函数添加到线程队列中同步执行（异步：执行完成后返回结果）

参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）

返回值：空

*/

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);

void dispatch_sync_f(dispatch_queue_t queue,

void *_Nullable context,

dispatch_function_t work);

/* 

功能：将块函数添加到线程队列中按照迭代次数执行，所有迭代完成后返回结果

参数：iterations：迭代次数  queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）

返回值：空

*/

void dispatch_apply(size_t iterations, dispatch_queue_t queue,

DISPATCH_NOESCAPE void (^block)(size_t));

dispatch_apply_f(size_t iterations, dispatch_queue_t queue,

void *_Nullable context,

void (*work)(void *_Nullable, size_t));



/* 

功能：获取当前执行中的队列

参数：无

返回值：当前队列或者空

*/

dispatch_queue_t dispatch_get_current_queue(void);

/* 

功能：获取主队列

参数：无

返回值：主队列或者空

*/

dispatch_queue_t dispatch_get_main_queue(void)

{

return DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);

}

/* 

功能：获取全局并发队列

参数：identifier：队列优先级  typedef long dispatch_queue_priority_t;

- DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED

- DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT

- DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY

- DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND



#define DISPATCH_QUEUE_PRIORITY_HIGH 2

#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0

#define DISPATCH_QUEUE_PRIORITY_LOW (-2)

#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN



  flags：保留供将来使用，输入除了0以外的任何值可能返回空值

返回值：全局队列或者空

*/

dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);





#define DISPATCH_QUEUE_SERIAL NULL  //串行队列

#define DISPATCH_QUEUE_SERIAL_INACTIVE//暂停状态串行队列

dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_SERIAL)

#define DISPATCH_QUEUE_CONCURRENT //并发队列

DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, _dispatch_queue_attr_concurrent)

#define DISPATCH_QUEUE_CONCURRENT_INACTIVE  //暂停状态并发队列

dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT)



/* 

功能：设置属性值，用于在队列的创建时加入

参数：attr：队列属性值

返回值：队列属性值

*/

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(

dispatch_queue_attr_t _Nullable attr);





#define DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL 

dispatch_queue_attr_make_with_autorelease_frequency(

DISPATCH_QUEUE_SERIAL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)



#define DISPATCH_QUEUE_CONCURRENT_WITH_AUTORELEASE_POOL

dispatch_queue_attr_make_with_autorelease_frequency(

 DISPATCH_QUEUE_CONCURRENT, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)



dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(

dispatch_queue_attr_t _Nullable attr,
dispatch_autorelease_frequency_t frequency);



/* 

功能：创建队列

参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一

返回值：引用的队列

*/



dispatch_queue_t dispatch_queue_create(const char *_Nullable label,

dispatch_queue_attr_t _Nullable attr);



dispatch_queue_t dispatch_queue_create_with_target(const char *_Nullable label,

dispatch_queue_attr_t _Nullable attr, dispatch_queue_t _Nullable target)



/* 

功能：获取队列描述信息

参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一

返回值：队列附带信息

*/

const char *dispatch_queue_get_label(dispatch_queue_t _Nullable queue);





//dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue,

int *_Nullable relative_priority_ptr);



/* 

功能：给指定对象设置目标队列

参数：object：目标对象  queue：目标队列

返回值：无

*/

void dispatch_set_target_queue(dispatch_object_t object,

dispatch_queue_t _Nullable queue);



/* 

功能：dispatch类入口函数

参数：无

返回值：无

*/

void dispatch_main(void);



/* 

功能：在指定时间后再目标队列执行block任务

参数：when：时间 queue：目标队列  block／work：要执行的任务  context：传入任务中的参数

返回值：无

*/

void dispatch_after(dispatch_time_t when,

dispatch_queue_t queue,

dispatch_block_t block);

void dispatch_after_f(dispatch_time_t when,

dispatch_queue_t queue,

void *_Nullable context,

dispatch_function_t work);



/* 

功能：给指定队列增加一个阻塞其它异步执行任务的任务

参数：queue：队列  block／work：任务  context：传入任务的参数

返回值：无

*/

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);

void dispatch_barrier_async_f(dispatch_queue_t queue,

void *_Nullable context,

dispatch_function_t work);

/* 

功能：给指定队列增加一个阻塞其它同步执行任务的任务

参数：queue：队列  block／work：任务  context：传入任务的参数

返回值：无

*/

void dispatch_barrier_sync(dispatch_queue_t queue,

DISPATCH_NOESCAPE dispatch_block_t block);

void dispatch_barrier_sync_f(dispatch_queue_t queue,

void *_Nullable context,

dispatch_function_t work);



/* 

功能：当指定队列键值改变时，或者是所有属性值都释放后，调用销毁函数destructor

参数：queue：队列  key：键名  context：新内容  destructor：销毁函数

返回值：无

*/

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key,

void *_Nullable context, dispatch_function_t _Nullable destructor);



/* 

功能：获取指定队列特定键内容

参数：queue：队列  key：键名  

返回值：键值

*/

void *_Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);

/* 

功能：获取当前队列特定键内容

参数： key：键名  

返回值：键值

*/

void *_Nullable dispatch_get_specific(const void *key);



/* 

功能：验证当前块任务运行在指定队列上

参数：queue：队列 

返回值：无

*/

void dispatch_assert_queue(dispatch_queue_t queue)

DISPATCH_ALIAS_V2(dispatch_assert_queue);

/* 

功能：验证当前块任务运行在指定队列上，并且该任务阻塞队列中的其它任务

参数：queue：队列 

返回值：无

*/

void dispatch_assert_queue_barrier(dispatch_queue_t queue);

/* 

功能：验证当前块任务没有运行在指定队列上

参数：queue：队列 

返回值：无

*/

void dispatch_assert_queue_not(dispatch_queue_t queue)

DISPATCH_ALIAS_V2(dispatch_assert_queue_not);







/******************************************************dispatch—group****************************************************/



/* 

功能：创建派遣队列组

参数：无

返回值：队列组

*/

dispatch_group_t dispatch_group_create(void);

/* 

功能：给指定队列添加异步执行任务，将队列加入组

参数：group：队列组 queue：指定队列  block／work：任务  context：传入任务的参数

返回值：无

*/

void dispatch_group_async(dispatch_group_t group,

dispatch_queue_t queue,

dispatch_block_t block);



void dispatch_group_async_f(dispatch_group_t group,

dispatch_queue_t queue,

void *_Nullable context,

dispatch_function_t work);

/* 

功能：等待（阻塞线程）一直到（队列组中所有任务执行结束或者是时间结束）

参数：group：队列组 timeout：时间

返回值：0表示成功，非0.错误

*/

long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);

/* 

功能：队列组中所有任务执行结束之后，执行新的block 任务

参数：group：任务组 queue：指定队列  block／work：新任务  context：传入任务的参数

返回值：任务组

*/

void dispatch_group_notify(dispatch_group_t group,

dispatch_queue_t queue,

dispatch_block_t block);



void dispatch_group_notify_f(dispatch_group_t group,

dispatch_queue_t queue,

void *_Nullable context,

dispatch_function_t work);



/* 

功能：管理显示队列组中所有任务

参数：group：队列组 

返回值：队列组

*/

void dispatch_group_enter(dispatch_group_t group);

/* 

功能：管理显示队列组中以执行结束的任务

参数：group：队列组

返回值：队列组

*/

void dispatch_group_leave(dispatch_group_t group);



/******************************************************dispatch—semaphore****************************************************/



/* 

功能：创建信号量

参数：value：信号量资源数

返回值：信号量或空（失败）

*/

dispatch_semaphore_t dispatch_semaphore_create(long value);

/* 

功能：等待获取信号量，获取到后开始继续执行，或是时间结束

参数：dsema：信号量 timeout：限定时间

返回值：无

*/

long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);

/* 

功能：执行结束，不需要占用资源，释放信号量

参数：dsema：信号量

返回值：无

*/

long dispatch_semaphore_signal(dispatch_semaphore_t dsema);



/******************************************************dispatch—object****************************************************/



/* 

功能：增加队列引用计数

参数：object：操作队列

返回值：无

*/

void dispatch_retain(dispatch_object_t object);

/* 

功能：减少队列引用计数

参数：object：操作队列

返回值：无

*/

void dispatch_release(dispatch_object_t object);

/* 

功能：获取对象应用程序上下文

参数：object：对象

返回值：定义内容或空

*/

void *_Nullable dispatch_get_context(dispatch_object_t object);

/* 

功能：设置指定对象的应用程序上下文

参数：object：对象 context：上下文内容

返回值：无

*/

void dispatch_set_context(dispatch_object_t object, void *_Nullable context);

/* 

功能：设置对象销毁函数，在该对象所有引用释放后，销毁该对象

参数：object：对象 finalizer：销毁函数指针

返回值：无

*/

void dispatch_set_finalizer_f(dispatch_object_t object,

dispatch_function_t _Nullable finalizer);

/* 

功能：激活指定非活动对象

参数：object：对象（一般是线程队列） 

返回值：无

*/

void dispatch_activate(dispatch_object_t object);

/* 

功能：挂起／阻塞指定对象（一般是线程队列）

参数：object：对象 

返回值：无

*/

void dispatch_suspend(dispatch_object_t object);

/* 

功能：恢复指定对象（一般是线程队列）

参数：object：对象 

返回值：无

*/

void dispatch_resume(dispatch_object_t object);

/* 

功能：同步等待一个对象完成操作，或者是直到超出规定时间

参数：object：对象  timeout：限定时间

返回值：0成功，非0失败

*/

long dispatch_wait(void *object, dispatch_time_t timeout);

/* 

功能：在指定对象完成工作后，将一个通知块任务加入指定队列

参数：object：对象  queue：队列 notification_block：通知块

返回值：无

*/

void dispatch_notify(void *object, dispatch_object_t queue,

dispatch_block_t notification_block);

/* 

功能：取消指定对象

参数：object：对象 

返回值：无

*/

void dispatch_cancel(void *object);

/* 

功能：判断指定对象是否被取消

参数：object：对象 

返回值：0表示未取消，其它表示取消

*/

long dispatch_testcancel(void *object);

/* 

功能：已编程方式记录指定对象的调试调度信息

参数：object：对象 

返回值：无

*/

void dispatch_debug(dispatch_object_t object, const char *message, ...);

void dispatch_debugv(dispatch_object_t object, const char *message, va_list ap);





/******************************************************dispatch—once****************************************************/



/* 

功能：只执行任务函数一次

参数：predicate：dispatch_once_t 对象  block／function要执行的任务函数 context：传入的内容

返回值：无

*/

void dispatch_once(dispatch_once_t *predicate,

DISPATCH_NOESCAPE dispatch_block_t block);

void dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context,

dispatch_function_t function);



/******************************************************dispatch—time****************************************************/



/* 

功能：创建时间对象，在指定时间的基础上再添加一段时间

参数：when：时间  delta：时间段（纳秒）

返回值：时间对象

*/

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);



/* 

功能：创建时间对象，在指定时间的基础上再添加一段时间

参数：when：时间  delta时间段（纳秒）

返回值：时间对象

*/

dispatch_time_t dispatch_walltime(const struct timespec *_Nullable when, int64_t delta);
```



# NSOperation

### 目录

- NSOperation
- 队列与操作
  - 队列NSOperationQueue
  - 操作NSOperation
- 阻塞
- NSOperation的API

### NSOperation

NSOperation是苹果GCD、面向对象的封装。

##### 相比GCD的优点:

##### 队列与操作：

既然是GCD的封装、自然逃不掉GCD的基本概念。操作与队列。

- #### 队列NSOperationQueue

三种向队列添加操作的方式

```css
- (void)addOperation:(NSOperation *)op;
- (void)addOperations:(NSArray<NSOperation *> *)ops waitUntilFinished:(BOOL)wait API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));
- (void)addOperationWithBlock:(void (^)(void))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));
```

##### 队列插入操作后的执行顺序：

首先、无论串行并行(并发数是否为1)的条件下。队列内操作的执行依赖两个要素。

- **如果所插入的操作存在依赖关系、优先完成依赖操作。**
- **如果所插入的操作不存在依赖关系、队列并发数为1下采用先进先出的原则、反之直接开辟新的线程执行**
   具体可以看下面的例子：

```objectivec
    //创建操作队列
    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];
    //创建最后一个操作
    NSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^{
        sleep(1);
        NSLog(@"最后的任务");
    }];
    for (int i=0; i<5-1; ++i) {
        //创建多线程操作
        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
            sleep(i);
            NSLog(@"第%d个任务",i);
        }];
        //设置依赖操作为最后一个操作
        [blockOperation addDependency:lastBlockOperation];
        [operationQueue addOperation:blockOperation];
        
    }
    //将最后一个操作加入线程队列
    [operationQueue addOperation:lastBlockOperation];
```

有依赖的情况下输出:

```css
2018-03-16 15:08:21.666983+0800 test[4524:404134] 最后的任务
2018-03-16 15:08:21.667267+0800 test[4524:404135] 第0个任务
2018-03-16 15:08:22.667647+0800 test[4524:404141] 第1个任务
2018-03-16 15:08:23.672276+0800 test[4524:404134] 第2个任务
2018-03-16 15:08:24.669316+0800 test[4524:404132] 第3个任务
```

相对的、我们可以取消依赖:注释掉`[blockOperation addDependency:lastBlockOperation];`

```css
2018-03-16 15:09:18.637169+0800 test[4551:406003] 第0个任务
2018-03-16 15:09:19.641270+0800 test[4551:406002] 第1个任务
2018-03-16 15:09:19.641270+0800 test[4551:406013] 最后的任务
2018-03-16 15:09:20.640994+0800 test[4551:406006] 第2个任务
2018-03-16 15:09:21.637335+0800 test[4551:406005] 第3个任务
```

我们也可以看看多线程的提现、另1号操作依赖addDependency:lastBlockOperation。看看其他操作会不会直接执行。

```objectivec
//设置依赖操作为最后一个操作
NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
       sleep(i);
       NSLog(@"第%d个任务",i);
}];
//设置依赖操作为最后一个操作
if (i == 1) {
     [blockOperation addDependency:lastBlockOperation];
}
[operationQueue addOperation:blockOperation];
```

结果确实是除了1号操作、其他的都立即被分配的其他线程执行了。

```css
2018-03-16 15:20:16.679755+0800 test[4753:424790] 第0个任务
2018-03-16 15:20:18.682874+0800 test[4753:424792] 第2个任务
2018-03-16 15:20:18.682875+0800 test[4753:424795] 最后的任务
2018-03-16 15:20:19.683923+0800 test[4753:424793] 第3个任务
2018-03-16 15:20:19.683923+0800 test[4753:424790] 第1个任务
```

##### 需要注意的是:

- 依赖必须在操作被添加到队列(确切来说应该是被执行)之前设置、否则无效。比如我们将一下两句调转:

```csharp
[operationQueue addOperation:blockOperation];
[blockOperation addDependency:lastBlockOperation];
```

输出的结果和注释掉依赖后相同:

```css
2018-03-16 15:10:48.814888+0800 test[4590:408731] 第0个任务
2018-03-16 15:10:49.817847+0800 test[4590:408732] 第1个任务
2018-03-16 15:10:49.817850+0800 test[4590:408731] 最后的任务
2018-03-16 15:10:50.815294+0800 test[4590:408733] 第2个任务
2018-03-16 15:10:51.815585+0800 test[4590:408730] 第3个任务
```

- 依赖在添加进队列之后虽然不能追加。但是可以对某操作进行追加`addExecutionBlock`、也可以延后操作的执行。

```objectivec
- (void)operationTest {
    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];
    
    NSBlockOperation * blockOperation1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"进入操作1");
        sleep(3);
        NSLog(@"操作1完成");
    }];
    
    NSBlockOperation * blockOperation2 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"进入依赖操作");
    }];
    
    [blockOperation2 addDependency:blockOperation1];
    
    [operationQueue addOperation:blockOperation1];
    [operationQueue addOperation:blockOperation2];
    
    [blockOperation1 addExecutionBlock:^{
        NSLog(@"进入追加操作");
        sleep(5);
        NSLog(@"追加操作完成");
    }];
}
```

打印结果:

```css
2018-03-20 13:00:55.635675+0800 test[2123:222591] 进入操作1
2018-03-20 13:00:55.635675+0800 test[2123:225319] 进入追加操作
2018-03-20 13:00:58.639154+0800 test[2123:222591] 操作1完成
2018-03-20 13:01:00.641240+0800 test[2123:225319] 追加操作完成
2018-03-20 13:01:00.641511+0800 test[2123:225319] 进入依赖操作
```

- 操作的依赖关系与本身绑定、并不受限于同一个队列。即使所执行的队列不同、也可以完成依赖操作。

```objectivec
    NSOperationQueue *operationQueue1=[[NSOperationQueue alloc]init];
    NSOperationQueue *operationQueue2=[[NSOperationQueue alloc]init];
    //创建最后一个操作
    NSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^{
        sleep(3);
        NSLog(@"最后的任务");
    }];
    NSBlockOperation *blockOperation0=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"第0个任务");
    }];
    NSBlockOperation *blockOperation1=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"第1个任务");
    }];
    [blockOperation1 addDependency:lastBlockOperation];
    [operationQueue1 addOperation:blockOperation1];
    [operationQueue1 addOperation:blockOperation0];
    
    [operationQueue2 addOperation:lastBlockOperation];
```

打印结果:

```css
2018-03-16 15:28:26.517760+0800 test[4874:439297] 第0个任务
2018-03-16 15:28:29.520710+0800 test[4874:439298] 最后的任务
2018-03-16 15:28:29.521107+0800 test[4874:439299] 第1个任务
```

##### 操作的追加

我们可以通过一下方法将新的操作追加到NSBlockOperation对象中

```cpp
- (void)addExecutionBlock:(void (^)(void))block;
```

但需要注意的是、追加的操作是并发执行的。具体的最大并发数、应该是由系统决定(因为我没找到哪个属性可以设置)。

```objectivec
    //主队列、必然是并发为1
    NSOperationQueue *operationQueue=[NSOperationQueue mainQueue];
    
    NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
        sleep(1);
        NSLog(@"第%d个任务--%@",10,[NSThread currentThread]);
    }];
    
    
    for (int i=0; i<10; ++i) {
        [blockOperation addExecutionBlock:^{
            sleep(1);
            NSLog(@"第%d个任务--%@",i,[NSThread currentThread]);
        }];
    }
    
    [operationQueue addOperation:blockOperation];
```

打印结果

```tsx
2018-03-16 16:21:38.739533+0800 test[5491:504081] 第0个任务--<NSThread: 0x60400026ea80>{number = 3, name = (null)}
2018-03-16 16:21:38.739535+0800 test[5491:504020] 第10个任务--<NSThread: 0x60400006a000>{number = 1, name = main}
2018-03-16 16:21:38.739537+0800 test[5491:504083] 第1个任务--<NSThread: 0x60400026a3c0>{number = 4, name = (null)}
2018-03-16 16:21:38.739565+0800 test[5491:504080] 第2个任务--<NSThread: 0x60000026ba80>{number = 5, name = (null)}
2018-03-16 16:21:39.739936+0800 test[5491:504083] 第5个任务--<NSThread: 0x60400026a3c0>{number = 4, name = (null)}
2018-03-16 16:21:39.739936+0800 test[5491:504020] 第4个任务--<NSThread: 0x60400006a000>{number = 1, name = main}
2018-03-16 16:21:39.739936+0800 test[5491:504080] 第6个任务--<NSThread: 0x60000026ba80>{number = 5, name = (null)}
2018-03-16 16:21:39.739936+0800 test[5491:504081] 第3个任务--<NSThread: 0x60400026ea80>{number = 3, name = (null)}
2018-03-16 16:21:40.741238+0800 test[5491:504020] 第7个任务--<NSThread: 0x60400006a000>{number = 1, name = main}
2018-03-16 16:21:40.741239+0800 test[5491:504083] 第8个任务--<NSThread: 0x60400026a3c0>{number = 4, name = (null)}
2018-03-16 16:21:40.741290+0800 test[5491:504080] 第9个任务--<NSThread: 0x60000026ba80>{number = 5, name = (null)}
```

- #### 操作NSOperation

两种个子类`NSBlockOperation`和`NSInvocationOperation`、(当然、你也可以继承出一个NSOperation)。

###### 操作的优先级

优先级只体现在两个时间点:

- 依赖任务处理完成、队列对后续任务的调度。
- 依赖队列从暂停转变为重新启动、后续任务的调度。

简而言之就是。在队列**同时**需要调度执行的任务中、会按照优先级排序执行。

如下所示(举个依赖完成的例子):

```objectivec
    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];
    
    operationQueue.maxConcurrentOperationCount = 1;
    
    NSBlockOperation *blockOperation1=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"低优先级任务");
    }];
    blockOperation1.queuePriority = NSOperationQueuePriorityLow;
    
    NSBlockOperation *blockOperation2=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"高优先级任务");
        sleep(1);
    }];
    blockOperation2.queuePriority = NSOperationQueuePriorityHigh;
    
    NSBlockOperation *blockOperation3=[NSBlockOperation blockOperationWithBlock:^{
        
    }];
    
    [blockOperation1 addDependency:blockOperation3];
    [blockOperation2 addDependency:blockOperation3];
    
    [operationQueue addOperation:blockOperation1];
    [operationQueue addOperation:blockOperation2];
    [operationQueue addOperation:blockOperation3];
```

打印结果:

```css
2018-03-16 18:33:52.435983+0800 test[6880:656581] 高优先级任务
2018-03-16 18:33:53.437498+0800 test[6880:656579] 低优先级任务
```

为了比较、我们可以把依赖去掉。这样执行顺序就会按照代码添加的顺序执行了。

```objectivec
    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];
    
    operationQueue.maxConcurrentOperationCount = 1;
    
    NSBlockOperation *blockOperation1=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"低优先级任务");
    }];
    blockOperation1.queuePriority = NSOperationQueuePriorityLow;
    
    NSBlockOperation *blockOperation2=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"高优先级任务");
        sleep(1);
    }];
    blockOperation2.queuePriority = NSOperationQueuePriorityHigh;

    
    [operationQueue addOperation:blockOperation1];
    [operationQueue addOperation:blockOperation2];
```

打印结果

```css
2018-03-16 18:30:40.293723+0800 test[6825:651558] 低优先级任务
2018-03-16 18:30:40.294005+0800 test[6825:651555] 高优先级任务
```

##### 阻塞

- ###### 操作阻塞`- (void)waitUntilFinished;`

阻塞当前线程、直到该操作执行完成。

```objectivec
    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];
    NSBlockOperation *blockOperation3=[NSBlockOperation blockOperationWithBlock:^{
        
        sleep(3);
        NSLog(@"操作3执行完毕");
    }];
    
    NSBlockOperation *blockOperation2=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"操作2开始执行");
        [blockOperation3 waitUntilFinished];
        NSLog(@"操作2执行完毕");
    }];
    [operationQueue addOperation:blockOperation2];
    [operationQueue addOperation:blockOperation3];
```

打印结果

```css
2018-03-19 10:40:11.856272+0800 test[1611:101411] 操作2开始执行
2018-03-19 10:40:14.857841+0800 test[1611:101413] 操作3执行完毕
2018-03-19 10:40:14.858028+0800 test[1611:101411] 操作2执行完毕
```

- ###### 队列阻塞`- (void)addOperations:(NSArray<NSOperation *> *)ops waitUntilFinished:(BOOL)wait;`

  - 如果为YES。阻塞当前线程、直到队列该次添加的所有操作全部执行完成。
  - 如果为NO。就是批量添加操作而已。

```objectivec
    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];
    NSBlockOperation *blockOperation3=[NSBlockOperation blockOperationWithBlock:^{
        sleep(3);
        NSLog(@"操作3执行完毕");
    }];
    NSLog(@"添加操作");
    [operationQueue addOperations:@[blockOperation3] waitUntilFinished:YES];
    NSLog(@"添加完成");
```

打印结果:

```css
2018-03-19 10:43:58.998232+0800 test[1690:108032] 添加操作
2018-03-19 10:44:02.000517+0800 test[1690:108155] 操作3执行完毕
2018-03-19 10:44:02.001007+0800 test[1690:108032] 添加完成
```

- ###### 线程/队列死锁:

这个不太好用语言描述。当阻塞生效时、若所依赖的操作无法并发完成。线程/队列将被锁死。举个例子：

```objectivec
    NSOperationQueue *operationQueue=[NSOperationQueue mainQueue];
    //pat1
    [operationQueue addOperations:@[blockOperation3] waitUntilFinished:YES];

    //blockOperation3的执行相当于被添加到最后
    //pat2
    blockOperation3();
```

最后的这个pat2将永远不会执行。因为主线程的并发为1、而这个1正在被占用。
 `pat1`等待`pat2`执行完毕。`pat2`又在等待着`pat2`执行完毕。造成死锁。
 **如果`operationQueue`的并发数为2、pat2将会被放到另一个线程去执行、执行完毕解锁当前线程。就不会出现死锁的问题。**

#### NSOperation的API

大概就一下这些东西、想看怎么用可以去开篇的帖子。或者自己搜搜。

- 操作：

可以KVC的状态(取消、进行、准备就绪、完成)/阻塞线程/completion回调/移除依赖等等....

```objectivec
@interface NSOperation : NSObject {
@private
    id _private;
    int32_t _private1;
#if __LP64__
    int32_t _private1b;
#endif
}

// 开始操作
- (void)start;

// 操作任务的入口，一般用于自定义NSOperation的子类 
- (void)main;

// 判断是否已经被取消
@property (readonly, getter=isCancelled) BOOL cancelled;

// 取消操作Operation，调用后不会自动马上取消，需要通过isCancelled方法检查是否被取消，然后自己编写代码退出当前的Operation
- (void)cancel;

// 是否正在执行
@property (readonly, getter=isExecuting) BOOL executing;

// 是否执行完
@property (readonly, getter=isFinished) BOOL finished;

// 判定该线程是否是并发线程，即调用该operation的start方法的线程是否与operation所在线程相同
// 注意：此属性即将被弃用，之后使用asynchronous属性代替
@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override 'asynchronous' below

// 是否异步执行
@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);

// 是否准备好
// 在start方法开始之前，需要确定Operation是否准备好，默认为YES，如果该operation没有准备好，则不会start。
@property (readonly, getter=isReady) BOOL ready;

// 添加依赖关系，如：[op1 addDependency:op2]; op2先执行，op1后执行  
- (void)addDependency:(NSOperation *)op;

// 取消依赖，注意：操作对象的依赖不能在操作队列执行时取消
- (void)removeDependency:(NSOperation *)op;

// 获取有依赖关系的Operation所组成的数组
@property (readonly, copy) NSArray<NSOperation *> *dependencies;

// Operation优先级的枚举
typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {
    NSOperationQueuePriorityVeryLow = -8L,
    NSOperationQueuePriorityLow = -4L,
    NSOperationQueuePriorityNormal = 0,
    NSOperationQueuePriorityHigh = 4,
    NSOperationQueuePriorityVeryHigh = 8
};

// 优先级
@property NSOperationQueuePriority queuePriority;

// Operation完成后调用的代码块
@property (nullable, copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);

// 堵塞当前线程，直到该Operation执行结束，才会执行接下来的代码
- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);

// 设定Operation的线程优先级，取值范围0~1，默认为0.5
// 即使设定了线程优先级，也只能保证其在该线程的main()方法范围内有效，Operation的其他代码仍然执行在默认线程
@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);

// 用于系统自动合理的管理队列的资源分配。
@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);

// 操作任务的名字
@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);

@end
```

**需要注意的是如果一个操作的状态为取消、进行、完成。是不可以被添加进队列的。**

- 对于队列：



```objectivec
// 默认最大操作数为-1、也就是由系统分配
static const NSInteger NSOperationQueueDefaultMaxConcurrentOperationCount = -1;

@interface NSOperationQueue : NSObject {
@private
    id _private;
    void *_reserved;
}

// 添加操作对象(NSOperation对象)
- (void)addOperation:(NSOperation *)op;

// 添加操作对象组(NSOperation对象)，waitUntilFinished:是否阻塞当前线程，等待所有操作都完成
- (void)addOperations:(NSArray<NSOperation *> *)ops waitUntilFinished:(BOOL)wait NS_AVAILABLE(10_6, 4_0);

// 添加操作任务
- (void)addOperationWithBlock:(void (^)(void))block NS_AVAILABLE(10_6, 4_0);

// 获取操作任务对象组
@property (readonly, copy) NSArray<__kindof NSOperation *> *operations;

// 获取操作任务对象总数
@property (readonly) NSUInteger operationCount NS_AVAILABLE(10_6, 4_0);

// 最大并发数
@property NSInteger maxConcurrentOperationCount;

// 是否暂停队列
@property (getter=isSuspended) BOOL suspended;

// 队列名字
@property (nullable, copy) NSString *name NS_AVAILABLE(10_6, 4_0);

// 用于系统自动合理的管理队列的资源分配
@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);

// underlyingQueue属性的值是主线程的调度队列，此属性不能设置为其它值
@property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue NS_AVAILABLE(10_10, 8_0);

// 取消所有操作任务
- (void)cancelAllOperations;

// 阻塞当前线程，等待所有操作执行完毕 
- (void)waitUntilAllOperationsAreFinished;

// 获取当前操作队列
+ (nullable NSOperationQueue *)currentQueue NS_AVAILABLE(10_6, 4_0);

// 获取主操作队列
+ (NSOperationQueue *)mainQueue NS_AVAILABLE(10_6, 4_0);

@end
```

