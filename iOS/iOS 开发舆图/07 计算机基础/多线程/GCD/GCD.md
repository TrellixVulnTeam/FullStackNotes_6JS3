### **总结**

- 先有队列，后又同步或者异步
- 什么时候同步？全局队列，串行队列，并行队列（能创建子线程的就可以有同步的操作，像主队列不存在子线程，就没有同步的说法，主队列一旦同步就会发生死锁）
- dispatch_sync需等block执行完才继续
- dispatch_async无需等block执行完可继续
- 并行和串行主要影响：任务的执行方式；并行：多个任务并发（同时）执行；串行：一个任务执行完毕后，再执行下一个任务。
- 同步和异步主要影响：能不能开启新的线程；同步：在当前线程中执行任务，不具备开启新线程的能力；异步：在新的线程中执行任务，具备开启新线程的能力。
- 开不开线程取决于任务时同步还是异步
- 开几条线程取决于串行还是并行
- GCD和NSThread不同，GCD维护一个线程池。根据线程池中的线程实际消耗来决定是否开新的线程。比如你创建了3个异步任务，但在执行第3个任务前第一个任务已执行完，就会把空出来的线程拿来直接用，而不需要开新的子线程。
- 假设你有任务T1和任务T2(这里的任务可以是进程也可以是线程):

a. 首先如果你的CPU是单核的, 为了实现"同时"执行T1和T2, 那只能分时执行, CPU执行一会儿T1后马上再去执行T2,

切换的速度非常快(这里的切换也是需要消耗资源的, context switch),

以至于你以为T1和T2是同时执行了(但其实同一时刻只有一个任务占有着CPU).

b. 如果你是多核CPU, 那么恭喜你, 你可以真正同时执行T1和T2了, 在同一时刻CPU的核心core1执行着T1,

然后core2执行着T2, great!

- 一个cpu同时只能运行一条线程，只不过通过时间片轮转，也就是cpu快速在多个线程之间调度（切换），如果cpu调度线程的时间够快，就造成了多线程并发执行的假象。
- 同步、异步决定是否创建子线程，同步任务不创建子线程，都是在主线程中执行，异步任务创建子线程。
- 串行、并行决定创建子线程的个数，串行创建一个子线程，并行创建多个子线程。
- 同步会阻塞线程，异步是开启另一个线程来执行，开启的这个是子线程。异步的子线程会在后台跑起来，甚至超过了主线程的速度，但是关于刷新UI的事情一定要回归主线程来执行。
- 主线程中不能使用同步。会发生循环等待（主线程等待该线程执行完毕，该线程需要调用主线程执行）
- 
- 一个任务必须声明在一个队列中，且要告诉是异步执行还是同步执行。
- 一个线程一个信息量，避免相互干扰
- 不同线程之间的信号量是否会相互干扰，或者说如果其中一个线程要耗费相当大的时间，其他线程是否也会被阻塞。
- 场景：在app开发中经常会遇到多个线程同时向服务器取数据，如果每个线程取得数据后都去刷新UI会造成界面闪烁；也有可能出现部分数据还没有获取完毕造成程序crash。

总结：其实我们平常说的并发编程包括狭义上的"并行"和"并发", 你不能保证你的代码会被并行执行,

但你可以以并发的方式设计你的代码. 系统会判断在某一个时刻是否有可用的core(多核CPU核心),

如果有就并行(parallelism)执行, 否则就用context switch来分时并发(concurrency)执行.

最后再以Ray大神的话结尾: Parallelism requires Concurrency,

but Concurrency does not guarantee Parallelism! 4.Yes!

和上面讨论狭义并发(Concurency)和并行(Parallelism)概念时的理解是一样的,

在单线程情况下(也就是mainQueue的主线程), 各个任务(在我们这里就是一个个的NSOperation)

可以通过分时来实现伪并行(Parallelism)执行. 而在多线程情况下,

多个线程同时执行不同的任务(各个任务也会不停的切换线程)实现task的并发执行.

### **GCD内部实现**

- GCD基于XNU内核实现。
- GCD的api全部再libdispatch库中
- GCD的底层实现主要由Dispatch Queue和Dispatch Source
- Dispatch Queue主要管理block操作
- Dispatch Source主要处理事件。

### **dispatch_async/dispatch_sync创建一个就代表一个任务吗？任务的概念是什么？NSOperation怎么创建一个任务？**

- 任务存在于队列中，没有添加进队列的任务，永远不会执行
- 默认是在主队列执行
- 一个作用域内的代码算一个任务吗？

### 

[单例队列创建](https://www.notion.so/805c85b6b3f341f7aec7e35080b2847d)